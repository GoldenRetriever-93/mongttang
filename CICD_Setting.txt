완전판 ci/cd 환경 세팅하기

---------------------------------------------------------------------------------------------------------------------
(선택) jupyter notebook => 이용 편의성을 위한 gui환경

sudo apt update
//jupyter notebook은 파이썬으로 동작하기 때문에, 패키지 관리 툴인 pip를 설치해준다.
sudo apt install python3-pip 
sudo pip3 install notebook

//python3 동작 시작
python3

from notebook.auth import passwd
passwd()
비밀번호 설정

비밀번호 해시값 저장 'argon2:$argon2id$v=19$m=10240,t=10,p=8$Ze4j/PKUoA5IzMWy3QY0RA$r2iY1k3bKm/NEjkyfsHRfbJ1mnGFK+og+J0ZEQk8Zbg'
exit()

주피터 환경 설정 파일을 만들어 비밀번호 접속을 활성화한다.

jupyter notebook --generate-config

	 // 에러 발생 : ImportError: cannot import name 'soft_unicode' from 'markupsafe' (/usr/local/lib/python3.8/dist-packages/markupsafe/__init__.py)

	MarkupSafe버젼 이슈라고 한다. 
	pip3 install markupsafe==2.0.1 로 버젼을 낮춰주자.

sudo vi (생성된 파일 주소)

c = get_config()
c.NotebookApp.password = u'비밀번호 해시값'
c.NotebookApp.ip = '현재 ec2의 로컬 ip'
c.NotebookApp.notebook_dir = '/'


//sudo jupyter-notebook --allow-root  //루트권한으로 jupyter notebook 실행
jupyter-notebook --allow-root 로 실행

//ImportError: cannot import name 'soft_unicode' from 'markupsafe' (/usr/local/lib/python3.8/dist-packages/markupsafe/__init__.py) 재발생
원인? 추정1) ERROR: nbconvert 7.2.9 has requirement jinja2>=3.0, but you'll have jinja2 2.10.1 which is incompatible.
해결: pip install --upgrade jinja2

진짜 원인 : markupsafe가 제대로 삭제되지 않음.
해결 : pip uninstall markupsafe로 전부 삭제 후 재설치

//문제 발생
jupytor notebook이 127.0.0.1로만 실행되는 문제
원인 : config파일을 제대로 인식하지 못하고 있음
해결 : jupyter notebook --config=[config파일 경로] 로 직접 세팅

//근본적 원인
jupyter noteboot은 root유저를 위한 config 파일이 /root/.jupyter에 별도로 존재한다.
sudo명령어로 실행시킬 경우, 이 파일을 읽어오려 시도하기 때문에 세팅이 읽히지 않았던 것이다.

ctrl+z 
bg      를 통해 백그라운드로 jupyter notebook을 돌려주고
(혹은 실행시 & 붙여서 실행)
disown -h으로 소유권을 포기하여 ssh연결이 끊겨도 계속 유지되도록 설정

시스템 서비스로 등록하기(ec2인스턴스가 재부팅 되었을 때 자동 실행)
	which jupyter-notebook 으로 실행파일 위치 확인
	sudo vi /etc/systemd/system/jupyter.service  서비스 파일 작성

	[Unit]
	Description = Jupyter Notebook Server

	[Service]
	Type=simple
	User=ubuntu
	ExecStart=/usr/bin/sudo (확인된 실행파일 위치) --allow-root --config=(설정 파일 위치)

	[Install]
	WantedBy=multi-user.target


작성 완료 후

	sudo systemctl daemon-reload
	sudo systemctl enable jupyter
	sudo systemctl start jupyter

--------------------------------------------------------------------------------------------------------------------

- mariadb 설치하기
	- 먼저 timezone을 확인하고 변경한다.
		- 확인 : date
		- 변경 : sudo timedatectl set-timezone 'Asia/Seoul'
	
	- 설치하기
		- 패키지 목록 최신화 : sudo apt update
		- 서버 설치 : sudo apt install mariadb-server
		- 마리아 db가 확실히 실행되는지 다시 체크 : sudo systemctl start mariadb.service  ==(동일)  sudo service mariadb start
	
	- 보안 설정
		- sudo mysql_secure_installation
		- root 사용자의 password는 설정하지 않기 때문에
			enter current password for root : 에서는 enter
			set root password? 에서 n을 입력해준다.
		- 익명 유저, test 데이터베이스를 없애고, root 원격 로그인을 막기 위해 Y를 입력해준다.

	- 새 유저 설정
		# 중요
		- MariaDB 10.3부터는 루트유저는 unix_socket을 사용하기 때문에 비밀번호를 사용하지 않는다. 문제가 생기는 것을 막기 위해 건드리지 말도록 하자.
		- sudo mysql로 root유저 접속이 가능하다.
		- 유저 생성 및 권한 주기
			```
			USE mysql;
			//새로 유저를 만든다. 내부 접속용이면 localhost를, 외부에서 접근을 모두 허용해주려면 %를 입력해준다.
			CREATE USER '유저이름'@'접속ip' IDENTIFIED BY '비밀번호';
			//유저에게 권한을 부여해준다.
			GRANT ALL PRIVILEGES ON 데이터베이스이름.* TO '유저이름'@'접속ip';
			//설정을 저장한다.
			FLUSH PRIVILEGES;
			```
		- unix_socket 사용을 원하지 않는다면 plugin을 공란으로 써주면 된다.
			```
			USE mysql;
			UPDATE user SET plugin='' where user='root';
			SET password = password('비밀번호');
			FLUSH PRIVILEGES;
			```
		- 유저 정보 변경은 update문을 이용하면 된다. flush privileges만 잊지말자
			ex) update user set password = password('새비밀번호') where user = '아이디' and host = '호스트 ip';
			flush privileges;

	- 외부에서 접근을 원한다면
		- sudo vi /etc/mysql/mariadb.conf.d/50-server.cnf 
		- sudo vim /etc/mysql/mariadb.conf.d/50-server.cnf (vim 설치시)
		- 주석처리되어있는 port = 3306을 주석 해제해준다.
		- bind-address를 0.0.0.0으로 변경해준다.

----------------------------------------------------------------------------------------------------------------------------------

nginx설치 및 개념

 nginx 
	- nginx 블록 기본 개념

		- 서버 블록
			- 서버 기능을 설정하는 블록으로 어떤 주소:포트로 요청을 받을지 결정한다.
			```
			server {
			    listen       80;
			    server_name  example.org  www.example.org;
			    ...
			}
			```
			- nginx -t 로 문법 검사 가능!
		- http 블록
			- 서버 블록 위에는 통신 블럭이 있어야 한다.
			- 그러나, include 문이 nginx.conf의 http 블럭 내부에 존재하므로 별도 작성하지 않아도 적용되어 있다.
		- location 블록
			- server 블록 내부에 작성한다.
			- location /main/ {
				return 200 "hello world";
				}
			- prefix match조건으로 prefix만 맞으면 뒤에 문자열이 무엇이든 동작한다 ex) main/nono와 mainnono 도 hello world를 반환한다.
			- =을 붙여 exact match 조건으로 변경할 수 있다. ex) location = /main
		- file return
			```
			server {
			    listen *:82;
			    #tmp/images 안의 파일들을 반환한다.
			    # :82/images/a.jpg
			    location /images {
				root /tmp;
			    }			

	- 설치 코드
		```
		sudo apt update
		sudo apt install nginx
		sudo service nginx start
		sudo service nginx status(상태확인)
		```
						
	- Nginx 기본 구성
		- 서버 블록을 사용해 구성 세부 정보를 캡슐화하고 한 서버에서 둘 이상의 도메인을 호스팅할 수 있다.
		- 기본적으로 /var/www/html의 하나의 서버 블록만 활성화되어있으며, /var/www/{도메인}/html로 디렉토리 구조를 수정하여야 한다.	

		- 콘텐츠
			- /var/www/html : 기본 Nginx 페이지가 있으며 구성 파일을 변경할 수 있다.
		- 서버 구성
			- /etc/nginx/nginx.conf : 기본Nginx 구성 파일. Nginx 전역 구성을 변경하도록 수정할 수 있다.
			- /etc/nginx/sites-available/ : 사이트별로 서버 블록을 저장할 수 있는 디렉토리.
				sites-enabled 디렉토리에 연결하지 않으면 이 구성 파일을 사용하지 않는다.
				sites-available에서 서버 블록을 구성한 후 다른 디렉토리에 연결하여 사용할 수 있게 된다.
			- /etc/nginx/sites-enabled : 활성화 된 사이트별 서버 블록이 저장되는 디렉토리.
				sites-available 디렉토리에 있는 구성파일에 연결하여 생성한다.
			- /etc/nginx/conf.d : 디렉토리에 있는 .conf 파일들이 서버 블록에 저장된다.(sites-available과 동일)
		- 서버 로그
			- /var/log/nginx/access.log : 웹 서버에 대한 모든 요청이 기록되는 곳
			- /var/log/nginx/error.log : 모든 Nginx 오류가 기록되는 곳.		
		- nginx.conf
			- sudo vim /etc/nginx/nginx.conf 로 파일 수정
			- 설정 파일이 최종적으로 들어가는 곳으로, 관리를 위하여 include /etc/nginx/conf.d/*.conf;와  include /etc/nginx/sites-enabled/*;로 다른 파일을 읽어와서 사용할 수도 있다.
		
	- 연동하기
		sudo mkdir /var/log/nginx/proxy/	# log, error 파일이 들어갈 디렉토리 생성
		sudo vi /etc/nginx/proxy_params

```
# 넘겨 받을 때 프록시 헤더 정보 지정
proxy_set_header X-Real-IP $remote_addr;
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
proxy_set_header Host $http_host;
proxy_set_header X-Forwarded-Proto $scheme;
proxy_set_header X-NginX-Proxy true;

client_max_body_size 256M;
client_body_buffer_size 1m;

proxy_buffering on;
proxy_buffers 256 16k;
proxy_buffer_size 128k;
proxy_busy_buffers_size 256k;

proxy_temp_file_write_size 256k;
proxy_max_temp_file_size 1024m;

proxy_connect_timeout 300;
proxy_send_timeout 300;
proxy_read_timeout 300;
proxy_intercept_errors on;
```

		- proxy_set_header XXX => 실제 요청 데이터를 header의 각 항목에 할당한다.
		ex) proxy_set_header X-Real-IP $remote_addr : Request  Header의 X-RealIP에 요청자의 ip 저장


		sudo vi /etc/nginx/sites-available/{domain}.conf

```
server { # server 블록
	listen 80;
	server_name {domain} www.{domain};
     
	access_log /var/log/nginx/proxy/access.log;
	error_log /var/log/nginx/proxy/error.log;

	location / { # location 블록
		include /etc/nginx/proxy_params;
		proxy_pass http://{퍼블릭IP주소}:8080;	# reverse proxy의 기능
	    }
}
```

		80포트로 들어오는 요청들에 대해 server_name과 일치하는 서버 블록을 찾고 location으로 uri를 매칭시킨다.
		proxy_pass를 통해 reverse proxy(client가 proxy서버에 접속했을 때, 적합한 내부 서버를 연결해주는 것)가 가능하다.
		
		- sudo ln -s /etc/nginx/sites-available/{domain} /etc/nginx/sites-enabled/ 로 sites-available 디렉토리부터 site-enabled에 링크를 생성하여 파일을 활성화한다.
		- 에러 발생을 막기 위해 default 파일을 삭제한다
			sudo rm /etc/nginx/sites-available/default
			sudo rm /etc/nginx/sites-enabled/default

------------------------------------------------------------------------------------------------------------------------------------------------------------------

# Docker 설치

sudo apt update
	sudo apt install apt-transport-https
	sudo apt install ca-certificates
	sudo apt install curl
	sudo apt install software-properties-common

	curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -	
	sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"

	sudo apt install docker-ce

	//작동 확인
	sudo docker pull hello-world
	sudo docker images
	sudo docker run hello-world

	//작동 후 컨테이너와 이미지를 삭제해주자
	sudo docker ps -a // 컨테이너 확인
	sudo docker rm (컨테이너ID)
	sudo docker images // 이미지 확인
	sudo docker rmi (이미지ID)

----------------------------------------------------------------------------------------------------------------------------------

#젠킨스 컨테이너 실행

docker run -d -p 8090:8080 -v /home/jenkins:/var/jenkins_home -v /var/run/docker.sock:/var/run/docker.sock -v /usr/bin/docker:/usr/bin/docker --name jenkins -u root jenkins/jenkins

	jenkins/jenkins로 젠킨스 최신 이미지를 설치한다.

	-p: 젠킨스는 기본 8080 포트를 사용하지만 스프링과 겹치므로 호스트의 8090포트와 매핑 시켜준다

	-v /home/jenkins:/var/jenkins_home: 호스트의 /home/jenkins 디렉터리와 젠킨스 컨테이너 내부의 jenkins_home 디렉터리를 매핑시켜 준다 나중에 호스트와 젠킨스 컨테이너 내부가 파일을 공유해야 할 때가 있다.

	-v /var/run/docker.sock:/var/run/docker.sock
	우린 젠킨스를 사용해서 도커로 말아진 nest 서버와 db를 build 해야 한다.
	이를 위해서 젠킨스 컨테이너 내부에서 도커 명령어를 사용해야 하고 호스트에 도커를 build 해야하기 때문에 /var/run/docker.sock:/var/run/docker.sock 으로 호스트와 컨테이너 내부 도커 데몬을 매핑하는 것이다.


	-v /usr/bin/docker:/usr/bin/docker
	docker를 연결해주어도 docker cli를 찾지 못해 명령어를 실행 못하는 경우가 있다. docker cli binary를 호스트에서 도커 내부로 매핑한다.


docker logs jenkins 

	=>로그를 확인하여 비밀번호를 확인 후 8090포트로 접속, 비밀번호 입력 후 plugin을 설치한다.

Jenkins 관리 => 플러그인 관리 => 설치가능 ssh 검색, Publish Over SSH, 지금 다운로드 => 재시작, 설치

새로운 item => pipeline

스크립트 작성

- pipeline  script vs pipeline script from scm
	- pipeline script : 젠킨스 웹 내에서 스크립트를 작성하고 관리한다
	- pipeline script from scm : 프로젝트 내에서 스크립트 작성 및 관리

- 문법(Groovy 기반)
	- Declarative Pipeline : 쉽게 작성 가능한 것이 장점(pipeline으로 시작하면 이 문법이다.)
	- Scripted Pipeline : 어렵지만 더 많은 기능이 있다.(node로 시작이면 이것이다.)

- 실제 작성

```

----------------------------------------------------------------------------------------------------------------------------
# nginx + certbot https 인증서 발급

sudo snap install certbot --classic

certbot certonly --nginx

이메일 입력 
Terms of Service -> yes
email 수신 여부 -> no
발급 받을 도메인 결정

/etc/nginx/sites-available/{도메인}.conf 변경

	```
	server {
    listen 80;    
    
    server_name i8a404.p.ssafy.io;
    
	location / {
        return 301 https://i8a404.p.ssafy.io$request_uri;
    }
}

	server {
        listen 443 ssl;    #추가

        server_name i8a404.p.ssafy.io www.i8a404.p.ssafy.io;

        access_log /var/log/nginx/proxy/access.log;
        error_log /var/log/nginx/proxy/error.log;

        ssl_certificate     /etc/letsencrypt/live/{도메인 이름}/fullchain.pem;   #추가
        ssl_certificate_key /etc/letsencrypt/live/{도메인 이름}/privkey.pem;   #추가

        location / {
                include /etc/nginx/proxy_params;
                proxy_pass http://localhost:3000/;
           	}

        location /api/ {
                include /etc/nginx/proxy_params;
                proxy_pass http://localhost:8080/;
	}
        }

	```

-------------------------------------------------------------------------------------------------------------------------------








# GitHub/GitLab와 Docker Hub 연동

docker hub 가입/로그인

create a docker repository

자동 빌드 기능은 이제 월 5달러 유료다 ㅠㅠ



돈 안내려면 docker pull push를 직접하자.



```
FROM node:8.10.0 as builder

# 작업 폴더를 만들고 npm 설치
RUN mkdir /usr/src/app
WORKDIR /usr/src/app
ENV PATH /usr/src/app/node_modules/.bin:$PATH
COPY package.json /usr/src/app/package.json
RUN npm install --silent
RUN npm install react-scripts@2.1.3 -g --silent

# 소스를 작업폴더로 복사하고 빌드
COPY . /usr/src/app
RUN npm run build



FROM nginx:1.13.9-alpine
# nginx의 기본 설정을 삭제하고 앱에서 설정한 파일을 복사
RUN rm -rf /etc/nginx/conf.d
COPY /etc/nginx/conf.d /etc/nginx

# 위에서 생성한 앱의 빌드산출물을 nginx의 샘플 앱이 사용하던 폴더로 이동
COPY --from=builder /usr/src/app/build /usr/share/nginx/html

# 80포트 오픈하고 nginx 실행
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]

```

/etc/nginx/conf.d에 default.conf 생성

vi /etc/nginx/conf.d/default.conf

```
server {
  listen 80;
  location / {
    root   /usr/share/nginx/html;
    index  index.html index.htm;
    try_files $uri $uri/ /index.html;
  }
  error_page   500 502 503 504  /50x.html;
  location = /50x.html {
    root   /usr/share/nginx/html;
  }
}

```



