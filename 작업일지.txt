# 23/03/08

- git setting
	- 각자 작업물을 올리는 branch는 study_개인 식별자로 결정
	- main에 관련된 권한 설정
	- branch naming 변경
		- git branch는 /를 파일 경로로 인식하여 문제가 생긴다.
		- 이름을 살짝 변경하여 문제를 우회하기로 결정
			- 브랜치 처음 생성땐 풀네임, 하위 브랜치는 축약어를 사용한다
				-  ex) backend => be/develop => be/dev/feature => ...

- nft Sub PJT
	- 과제 1 : ERC721 구현
		- openzeppelin의 코드를 직접 쳐보며 문법 및 작동 방식을 익혔다.
	- 과제 2: NFT Creator 구현
		- 참고) https://www.youtube.com/watch?v=TYezN5r228U
			- nft 생성 과정
			1) 이미지를 ipfs에 올린다.
			2) metadata JSON 파일을 ipfs에 올린다.
			3) ERC721민터 코드를 블록체인에 올린다.
			4) NFT를 민트한다
			5) 지갑에서 확인한다.
			
			- erc721이란?
				- nft의 표준, ERC20에 토큰 ID, metadata JSON 추가된 것
				- 토큰 ID? NFT에 붙는 개별 식별 번호 => nft를 고유한 것으로 만든다.
				- 메타데이터 json => nft에 넣을 정보를 담는 그릇

			- ipfs란?
				- 위변조 불가능한 저장소
				- 블록체인을 활용한 p2p 분산형 웹 저장소이다.
				- 블록체인 자체에 image와 metedata를 넣기엔 비싸기 때문에 ipfs를 사용한다.
	- 과제 3: 테스트 코드 작성 중
		- Mocha
			- truffle은 내부적으로 테스트를 위하여 mocha 프레임워크를 사용한다.
			- 컨트랙트를 배포한 후, truffle test ./test/<FILENAME>으로 테스트를 실행하면 test 폴더 하위의 js 파일들이 모두 실행된다.

----------------------------------------------------------------------------------------------------------------------------------

# 23/03/09

- nft Sub PJT
	- 과제 2 수정
		- Counters.Counter 사용
			- OpenZeppelin이 제공하는 library.
			- counter는 storage를 사용하여 thread-safe하게 동작한다. 
	- 과제 3 test code 작성
		- web3의 통신 방식
			- 함수.call()로 함수를 호출할 경우 read only, 즉 local로 작동된다
			- 함수를 호출할 때, transaction이 발생하는 함수라면, return값은 transaction hash가 된다. 값은 logs[0].args[2]에 들어있다.
			- transaction이 발생하지 않는 함수라면, return 값은 주어진 대로 온다.
			- uint 값의 경우 BN(big number)라는 객체의 형식으로 오는데, 숫자처럼 사용이 가능하다.
	- 과제 4 배포
		- truffle migrate나 truffle test를 사용하기 위해서는 ganache가 설치되어 있어야 한다.
		- npm install -g ganache-cli로 설치 가능
		- 터미널을 하나 더 실행시킨 뒤 ganache-cli로 실행시킨다.

- infra 설계
	- S3 저장 구조 토의
		/users
		  └  /[이용자id]
			  └  /profile.jpg
		/books
		  └  /[챌린지id]
			  └  /[동화id]
				  └  /page0.jpg
				  └  /page1.jpg
				  └  ...

--------------------------------------------------------------------------------------------

# 23/03/10

- nft 개발
	- erc721기반 nft 생성 및 전송 테스팅 완료
	- erc20 기반 토큰 생성 및 테스팅 완료
	- 고민 사항
		- 현재 openzeppelin 코드를 import해서 사용 중인데, 직접 개발을 할 것인가?
		- 어떤 network를 사용할 것인가?
			=> private network 이용하기로 결정

- infra
	- ec2인스턴스에 ipfs와 geth 도커 컨테이너 생성해야 한다. 
		- 성능 제한을 얼마나 둘까?


------------------------------------------------------------------------------------

# 23/03/13

- infra
	- git 접근 권한 변경
		- backend, frontend, blockchain과 그 하위의 dev 폴더들에 대하여 push 금지 설정
		- gitIgnore 파일 브랜치에서 생성 후 dev폴더에 merge한 후, 향후 개발하는 브랜치는 dev브랜치에서 사용하도록 약속
	
	- ec2 설정
		- jupyter notebook 설치
			- 오류가 많이 났다.
				- 문제 1 : 에러메세지 발생. 켜지기는 하지만 여러 문제가 발생. 이것이 근원적 문제였는지는 알 수 없음.
					- 오류 : ERROR: nbconvert 7.2.9 has requirement jinja2>=3.0, but you'll have jinja2 2.10.1 which is incompatible.
					- 해결 :  pip install --upgrade jinja2
				- 문제 2 : /ImportError: cannot import name 'soft_unicode' from 'markupsafe' (/usr/local/lib/python3.8/dist-packages/markupsafe/__init__.py) 발생. 기존 해결책(2.0.1 설치) 적용 안됨.
					- 원인 : markupsafe가 제대로 삭제되지 않는 현상으로 추정됨.
		        			- 해결 : pip uninstall markupsafe로 전부 삭제 후 재설치
				- 문제 3 : jupytor notebook이 지속적으로 127.0.0.1에서만 실행된다
					- 원인 : config 파일을 제대로 인식하지 못하고 있음. 문제 1과 연관 가능성 높음
					- 해결 : jupyter notebook --config=[config파일 경로]로 직접 세팅
				- 문제 4 : 종료 후 재 실행시 문제 반복
					- 원인 및 해결 : jupyter noteboot은 root유저를 위한 config 파일이 /root/.jupyter에 별도로 존재한다.
						sudo명령어로 실행시킬 경우, 이 파일을 읽어오려 시도하기 때문에 세팅이 읽히지 않았던 것이다.

		- nginx 설치 및 설정
			- 기존에 blue-green 배포 전략이 실패한 이유는 차후 다시 실험하여 재현한 후 질문을 해보도록 하자.

----------------------------------------------------------------------------------

# 23/03/14

- infra
	- ec2 설정
		- docker 설치
		- jenkins(dockerize)
		- maria db 설치
			- 기존에는 유저 접속 ip를 %(어디든)으로 주었지만, 이번에는 보안을 위해 제한을 두자
				- MariaDB 접속 후 : CREATE USER '유저이름'@'접속ip' IDENTIIFED BY '비밀번호';
				- /etc/mysql/mariadb.conf.d/50-server.cnt에서 bind-address를 접속할 ip로 설정.
				- 내부에서 접근하게 될 것 같으므로 ec2 로컬 ip를 사용하도록 설정.
				- 개발 단계에서는 편의를 위해 ip를 열어두자. 잊지 말고 배포시에 변경할 것!
			
	- ci/cd 관련 파일들 재정리

-------------------------------------------------------------------------------------

# 23/03/15

- block chain 재기획
	- 프로세스
		- 챌린지가 끝나면 각 동화에 nft가 발행된다.
		- 지난 챌린지는 유료가 되며 이용자가 지불한 금액의 일부는 거래소의 지갑으로, 일부는 토큰에 저장이 된다.
		- 지불 수단은 자체적으로 발행한 erc20 코인이다.
		- erc20 코인은 ssf(싸피 코인)과 거래가 가능한 거래소 기능이 존재한다.
		- nft의 주인은 지갑에서 출금하기 버튼으로 각 nft에 들어있는 거래소 코인을 자신의 지갑에 넣을 수 있다.
		- 수수료의 지급 방식이 소유자 의존적이지 않기 때문에, 탈중앙화된 nft의 거래가 가능하다.
	- 구현 페이지
		- 지갑 페이지
			- 현재 보유중 ssf 표시
			- 현재 보유중 erc20 표시
			- erc20 구매 페이지(미니 거래소)
			- 현재 보유중인 nft 표시
			- nft가 저장한 erc20양 표시
			- nft의 erc 꺼내오는 버튼
		- 미니 거래소
			- 실시간으로 매물이 보이는 gui
			- 매도 기능
			- 매수 기능
		- nft 경매소(추가 구현 사항)

# 배운 점
	프로젝트를 진행함에 있어서 반드시 여러 기술을 사용해보는 것만이 좋은 경험이 아니다.
	실제 프로세스를 어떻게 구성하였으며 어떤 아이디어로 어떤 서비스를 구현하였는지가 더 중요하다.
	실제 인터뷰에서도 힘들었던 경험 등에 기술적 구현이 힘들었던 부분보다는 운영적인 부분에서 어려웠던 점을 이야기 해보는 것도 색다를 수 있다.
------------------------------------------------------------------------------------------------------	

# 23/03/16

- block chain 관련 명세서 추가
- ipfs 이슈 발견 : local ipfs에서 add한 file을 public에서 access 불가한 문제
	- peer가 없는 것 확인 : ssafy 방화벽의 문제 가능성
		- ec2에서 작동 확인 => 설치는 완료했으나 webui 접속 불가. localhost에서도 같은 증상 있는데 원인이 불명임.

-------------------------------------------------------------------------------------------------------------------

# 23/03/17

- 코인 거래관련 백엔드 구현 사항 및 db 토의
	- 필수 db 구현 사항
		- 유저 귀속 정보 : ssafy coin 보유량(int), mongttang coin 보유량(int), 보유 nftId(int 배열) =>관리의 편의성을 위하여 user table과 연관관계는 갖지 않기로
		- 거래소 테이블 : 가격별 매도, 매수량 => 각 가격별로 별도의 테이블 생성하여 사람, 일자, 매도량/매수량 기록.
	- 필수 api 구현 사항
		- 개인 보유량/전체 거래량/개인 예약 거래 정보 보기
		- 거래 요청시 그 이상/이하의 매수/매도 가격이 있다면 선입선출식으로 계산
		- 입금, 출금시 정산하는 절차

- ipfs setting
	- 설치 : docker pull ipfs/kubo
	- 파일 저장 위치 설정
		- export ipfs_staging=</absolute/path/to/somewhere/> : 입력 데이터 저장하는 곳
		- export ipfs_data=</absolute/path/to/somewhere_else/>	 : 출력 데이터 저장하는 곳
	- 도커 실행
		- docker run -d --name ipfs_host -v $ipfs_staging:/export -v $ipfs_data:/data/ipfs -p 4001:4001 -p 4001:4001/udp -p 127.0.0.1:8080:8080 -p 127.0.0.1:5001:5001 ipfs/kubo:latest
		- 127.0.0.1(localhost)로 설정하여 외부 연결을 차단한다. 공식 권고 사항. 8080포트는 겹칠 일이 많으므로 잘 바꿔 쓰자.
		- docker logs -f ipfs_host 로 정상적으로 실행되는지 확인
	- ipfs 컨테이너에 명령하기
		- docker exec ipfs_host ipfs swarm peers  피어에 연결한다.
		- cp -r <something> $ipfs_staging   파일을 staging에 복사한다. -r옵션을 사용해야 폴더 내부의 폴더까지 복사한다.
		docker exec ipfs_host ipfs add -r /export/<something> 파일을 ipfs에 넣는다.
	- 공식 설명 : https://docs.ipfs.tech/install/run-ipfs-inside-docker/#set-up

- ipfs 진행 상황
	- upload(add) 되는 것 확인 완료.
	- get 요청 저장 위치 확인 안됨(to do)
	- webui로 접근해서 안뜬다는 이슈 전해받음.

-------------------------------------------------------------------------------------------------------------------

# 23/03/20

- S3 업로더 구현
	- infra
		- S3 생성
		- IAM 계정 생성(S3 권한 전권 허요)
		- cloudfront 연동
	- Backend
		- S3Service 구현
			- profile의 경우 같은 이름의 파일 삭제 후 업로드. 파일 삭제시 404 not found가 발생 가능하여 해당 함수에 에러처리 해 둠.
			- book의 경우 반복문으로 작동이 필수적. 해당 파일이 없는 경우 사이즈가 리스트의 크기가 0이므로 반복문이 돌지 않아 별도로 에러 처리하지 않음.
	- 파일 구조 노션의 convention에 정리.

-------------------------------------------------------------------------------------------------------------------

# 23/03/21

- ERC721 구현
	- openzeppelin 기반
		- ERC721, Ownable 상속
		- NFT 발급 기능을 Owner에게 제한
		- ERC20이 각 NFT에 deposit/withdraw 될 수 있도록 구현
		- 그림을 토큰화 할 수 있도록 파일의 주소값을 토큰화하도록 구현
- ERC20 구현
	- openzeppelin 기반
		- ERC20 상속
		- minting이 배포시 한 번만 일어나도록 설정(총 발급량 고정)
		- 발급자의 보유량을 볼 수 있는 함수 제공
		- 소수 허용 x

- 지갑 기능 구현
	- 외관적 틀만 형성됨

-----------------------------------------------------------------------------------------------------------------------

# 23/03/22

- Truffle 배포 이슈
	- Ssafy network 상 gas비용이 0임에도 불구하고 gas비용 부족으로 배포가 되지 않음
	=> 해결 : remix ide로 배포

- 거래 구조 재설계
	- DB에서 거래 후 정산하는 대신 실제 transaction을 내도록 함.
	- 이유
		1. 정산시에만 transaction이 일어나면 아무런 거래도 트래킹 되지 않음 => 블록체인이 무의미해짐
		2. ERC721에 ERC20을 넣는 기능이 의미가 없어짐 => 1과 동일
		3. ssafy network 속도와 반응성이 이용 가능한 수준임
		4. 토큰의 입출입 관련 로직이 심플해짐
		5. 별도의 지갑 앱으로 확장성을 가지게 됨

- 지갑 변경
	- back과의 통신 코드를 ssafy-network와의 통신으로 변경
	- 통신 test 완료

- MongttangNFT 변경
	- 존재하지 않는 토큰에 입금가능한 문제 수정
	- getMyNFTs 함수 추가 : 전송자의 nft 보유 목록 확인 가능

- IPFS 테스팅
	- 재 테스팅 결과 속도가 충분히 빨라 이용 가능한 수준임으로 판별.

--------------------------------------------------------------------------------------------------------------------------------

# 23/03/23

- MongttangNFT(ERC721)
	- getMyNFTs가 배열로 nft들의 id와 잔액을 가져오도록 설정

- Vue에서 blockchain 통신 기능 진행중
	- read only method 호출 완료.
		- Ssf 잔액
		- Mtt 잔액
		- 보유 nft 목록 및 잔액
	- privatekey로 연결 주소 설정 완료.
	- 쿼리스트링으로 privatekey 받도록 설정 => vuex의 state에서 관리

--------------------------------------------------------------------------------------------

# 23/03/24

- 배포작업
	- jenkins => git lab 연동
		- deploy token을 통해 repository에 접근 권한 부여
			- access token 이용해 접근 권한 부여하는 것은 git lab api를 통해 연결 후 다시 git lab ssh 연결을 해야하는데, 사용성이 너무 안 좋은 것 같다.
			- deploy token을 이용하면 별도 설정 없이 id, password를 대신하여 접근권한을 부여할 수 있다.
		- webhook을 통하여 특정 branch의 push상태를 읽어 자동 빌드 설정 완료. 
	- Spring 배포
		- 해결한 이슈들
		- application.yml의 위치 문제
			- application.yml은 git에 upload되지 않아 직접 ec2내부에 생성해주어야 한다. 외부에 파일을 만든 후, 구동시에 --spring.config.loaction 옵션으로 처리하려 했으나, 빌드시에 에러를 겪에 됨.
			- 결국 git을 pull 받은 후, 내부에 새로 생성해 주는 것으로 해결.
		- docker not found 문제
			- jenkins 구동중인 container에 docker.sock을 매핑해도 docker 명령어를 인식하지 않는 문제 발생 
			- "-v /usr/bin/docker:/usr/bin/docker"를 추가해서 해결

-----------------------------------------------------------------------------------------------

# 23/03/27

- Spring 배포 과정 오류 해결
	- 원인 : dockerfile syntax error
	- 상세 : dockerfile에서 스페이스는 문자로 인식되므로 명령어를 구분할 때를 제외해선 사용해선 안된다.

- Ngingx reverse proxy 미작동 오류 해결
	- 원인 : nginx 설정 파일의 포트 번호를 변경한 후 reload하지 않음

- MongttangNFT 수정
	- NFT별 총 누적 금액 추가
	- getMyNFTs 함수 return값을 2차원 배열에서 1차원 배열 3개로 변경 : nftIds, nftBalances, nftTotalEarneds
	- 변경 사항에 맞게 nftList.vue 변경
	- 사용성을 위한 디자인 요청함

------------------------------------------------------------------------------------------------------

# 23/03/28

- nft 생성하기 기능 완료
	- 생성 받을 주소, tokenURI 값을 인자로 받고 contract 배포자의 privateKey는 저장되어있는 파일에서 불러온다.
	- privateKeyToAccount(배포자 privateKey)를 이용하여 ownerAccount 생성, ownerAccount.address로 주소값을 가져온다.
	- getTransactionCount(ownerAccount.address)로 nonce 값을 가져온다.
		- nonce란 주소가 보내는 요청의 번호로 네트워크에 대한 replay attack을 막기 위해 사용한다.
	- 받은 정보로 transactionObject를 생성한 뒤, signTransaction(transactionObject, SITE_PRIVATE_KEY)를 통해 서명한다.
	- sendSignedTransaction(signedTx.rawTransaction) 로 요청을 보내면 완료
	- 반환 값은 promievent로 promise에 on, once, off 세 가지를 더한 객체이다. on('receipt[error]', (receipt[error]) => {})로 callback 함수를 부를 수 있다.

----------------------------------------------------------------------------------------------------

# 23/03/29

- 토큰 거래 기능 완료
	- 이슈 사항 : 네크워크에서 revert되는 문제
		- 원인 : transferFrom을 사용했기 때문, transfer 함수로 변경하자 작동
	- 이슈 사항2 : 거래 실패시 에러 처리가 불가능함
		- 해결 : then, catch 대신 async await와 try catch문으로 간략화하고 return 값으로 거래 성공시 true 실패시 false를 반환하여 if문으로 에러 처리 성공
	- 이슈 사항3 : 거래 중 화면을 끄거나 새로고침하면 js 코드의 동작이 중단됨
		- 해결 : vue에서 직접 web3 통신을 하는 이상 해결이 불가능함. node.js로 지갑용 백엔드 서버를 하나 더 구동시켜야 함.

-----------------------------------------------------------------------------------------------------------